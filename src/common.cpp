//
// Created by root on 9/10/18.
//

#include "common.h"
#include <boost/thread.hpp>
#include "device_alternate.h"
#include "rng.h"


namespace caffe{

    // Make sure each thread can have different values.
    static boost::thread_specific_ptr<Caffe> thread_instance_;

    Caffe& Caffe::Get() {
        if (!thread_instance_.get()) {
            thread_instance_.reset(new Caffe());
        }
        return *(thread_instance_.get());
    }

    // random seeding
    int64_t cluster_seedgen(void) {
        int64_t s, seed, pid;
        FILE* f = fopen("/dev/urandom", "rb");
        if (f && fread(&seed, 1, sizeof(seed), f) == sizeof(seed)) {
            fclose(f);
            return seed;
        }

        LOG(INFO) << "System entropy source not available, "
                "using fallback algorithm to generate seed instead.";
        if (f)
            fclose(f);

        pid = getpid();
        s = time(NULL);
        seed = std::abs(((s * 181) * ((pid - 83) * 359)) % 104729);
        return seed;
    }

    Caffe::Caffe()
            : random_generator_(), mode_(Caffe::CPU),
              solver_count_(1), root_solver_(true) { }

    Caffe::~Caffe() { }

    void Caffe::set_random_seed(const unsigned int seed) {
        // RNG seed
        Get().random_generator_.reset(new RNG(seed));
    }

    void Caffe::SetDevice(const int device_id) {
        NO_GPU;
    }

    void Caffe::DeviceQuery() {
        NO_GPU;
    }

    bool Caffe::CheckDevice(const int device_id) {
        NO_GPU;
        return false;
    }

    int Caffe::FindDevice(const int start_id) {
        NO_GPU;
        return -1;
    }

    class Caffe::RNG::Generator {
    public:
        Generator() : rng_(new caffe::rng_t(cluster_seedgen())) {}
        explicit Generator(unsigned int seed) : rng_(new caffe::rng_t(seed)) {}
        caffe::rng_t* rng() { return rng_.get(); }
    private:
        shared_ptr<caffe::rng_t> rng_;
    };

    Caffe::RNG::RNG() : generator_(new Generator()) { }

    Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }

    Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
        generator_ = other.generator_;
        return *this;
    }

    void* Caffe::RNG::generator() {
        return static_cast<void*>(generator_->rng());
    }


}
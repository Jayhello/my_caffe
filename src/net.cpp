//
// Created by root on 9/12/18.
//

#include "net.h"
#include "upgrade_proto.h"
#include "insert_splits.h"
#include "layer_factory.h"
#include "device_alternate.h"
#include "io.h"

namespace caffe{

template<typename Dtype>
Net<Dtype>::Net(const NetParameter &param, const Net<Dtype> *root_net):root_net_(root_net) {
    Init(param);
}

template <typename Dtype>
Net<Dtype>::Net(const string& param_file, Phase phase, const Net* root_net)
        : root_net_(root_net) {
    NetParameter param;
    ReadNetParamsFromTextFileOrDie(param_file, &param);
    param.mutable_state()->set_phase(phase);
    Init(param);
}

    template<typename Dtype>
    void Net<Dtype>::Init(const NetParameter &in_param) {
        CHECK(Caffe::root_solver() || root_net_)
        << "root_net_ needs to be set for all non-root solvers";

        // 得到是训练网络还是测试网络
        phase_ = in_param.state().phase();

        // 传入网络结构参数，然后可以根据LayerParameter中的
        // include和exclude来确定该层是否应该包含在网络中，返回过滤过后的网络参数
        NetParameter filtered_param;
        FilterNet(in_param, &filtered_param);

        LOG_IF(INFO, Caffe::root_solver())
        << "Initializing net from parameters: " << std::endl
        << filtered_param.DebugString();

        /*
         * InsertSplits函数，若某层的top(即输出)被两个或两个以上的层作为输入或输入的一部分，
         * 则对该层增加空间位置与其成并列关系的一个或若干个SplitLayer。(每仔细看)
         */
        NetParameter param;
        InsertSplits(filtered_param, &param);

        // Basically, build all the layers and set up their connections.
        name_ = param.name();
        map<string, int> blob_name_to_idx;

        set<string> available_blobs;
        memory_used_ = 0;

        // resize是改变容器的大小，并且使用默认构造函数创建对象
        // 参数初始化
        bottom_vecs_.resize(param.layer_size());
        top_vecs_.resize(param.layer_size());
        bottom_id_vecs_.resize(param.layer_size());
        param_id_vecs_.resize(param.layer_size());
        top_id_vecs_.resize(param.layer_size());
        bottom_need_backward_.resize(param.layer_size());

        // 循环每一层
        for (int layer_id = 0; layer_id < param.layer_size(); ++layer_id) {

            // For non-root solvers, whether this layer is shared from root_net_.
            // 默认为false
            bool share_from_root = !Caffe::root_solver()
                                   && root_net_->layers_[layer_id]->ShareInParallel();

            // Inherit phase from net if unset.
            // 如果每一层没有设置phase，则从网络参数中继承
            if (!param.layer(layer_id).has_phase()) {
                param.mutable_layer(layer_id)->set_phase(phase_);
            }

            // Setup layer.
            // 没一层的结构参数常量
            const LayerParameter& layer_param = param.layer(layer_id);

            // 是否设置了对输入求导,参考caffe.proto里LayerParameter的propagate_down参数
            if (layer_param.propagate_down_size() > 0) {
                CHECK_EQ(layer_param.propagate_down_size(),
                         layer_param.bottom_size())
                    << "propagate_down param must be specified "
                    << "either 0 or bottom_size times ";
            }


            if (share_from_root) {
                LOG(INFO) << "Sharing layer " << layer_param.name() << " from root net";
                layers_.push_back(root_net_->layers_[layer_id]);
                layers_[layer_id]->SetShared(true);
            }
            else {

                //把每一特定层的指针存放在容器中
                layers_.push_back(LayerRegistry<Dtype>::CreateLayer(layer_param));

            }

            //存放网络中每一层的名称
            layer_names_.push_back(layer_param.name());
            LOG_IF(INFO, Caffe::root_solver())
            << "Creating Layer " << layer_param.name();

            // 判断每层是否需要反向传播
            bool need_backward = false;

            // Figure out this layer's input and output
            // 计算这一层的输入和输出,注意第一层他妈的没有输出bottom，所以在第一层的时候并不会进入循环
            // 这个地方耽误了半天，妈的
            for (int bottom_id = 0; bottom_id < layer_param.bottom_size();
                 ++bottom_id) {
                //LOG(INFO) <<  " -> " <<" "<<(blob_name_to_idx).size()<<"sbheheda";
                const int blob_id = AppendBottom(param, layer_id, bottom_id,
                                                 &available_blobs, &blob_name_to_idx);

                need_backward |= blob_need_backward_[blob_id];
            }

            // 每一层输出数据的个数
            int num_top = layer_param.top_size();


            // 对每层的每个输出数据
            for (int top_id = 0; top_id < num_top; ++top_id) {

                AppendTop(param, layer_id, top_id, &available_blobs, &blob_name_to_idx);

                // Collect Input layer tops as Net inputs.
                if (layer_param.type() == "Input") {

                    const int blob_id = blobs_.size() - 1;
                    net_input_blob_indices_.push_back(blob_id);
                    net_input_blobs_.push_back(blobs_[blob_id].get());

                }
            }

            // If the layer specifies that AutoTopBlobs() -> true and the LayerParameter
            // specified fewer than the required number (as specified by
            // ExactNumTopBlobs() or MinTopBlobs()), allocate them here.
            Layer<Dtype>* layer = layers_[layer_id].get();
            if (layer->AutoTopBlobs()) {
                const int needed_num_top =
                        std::max(layer->MinTopBlobs(), layer->ExactNumTopBlobs());
                for (; num_top < needed_num_top; ++num_top) {
                    // Add "anonymous" top blobs -- do not modify available_blobs or
                    // blob_name_to_idx as we don't want these blobs to be usable as input
                    // to other layers.
                    AppendTop(param, layer_id, num_top, NULL, NULL);
                }
            }

            // After this layer is connected, set it up.
            if (share_from_root) {
                // Set up size of top blobs using root_net_
                const vector<Blob<Dtype>*>& base_top = root_net_->top_vecs_[layer_id];
                const vector<Blob<Dtype>*>& this_top = this->top_vecs_[layer_id];
                for (int top_id = 0; top_id < base_top.size(); ++top_id) {
                    this_top[top_id]->ReshapeLike(*base_top[top_id]);
                    LOG(INFO) << "Created top blob " << top_id << " (shape: "
                              << this_top[top_id]->shape_string() <<  ") for shared layer "
                              << layer_param.name();
                }
            }

            else {
                // 设置layers实例
                // 调用layer类的Setup函数进行初始化，输入参数：每个layer的输入blobs以及输出blobs
                // 为每个blob设置大小
                // 设置每一层的可学习参数，保存早layer的成员blobs_中
                layers_[layer_id]->SetUp(bottom_vecs_[layer_id], top_vecs_[layer_id]);
            }

            LOG_IF(INFO, Caffe::root_solver())
            << "Setting up " << layer_names_[layer_id];

            // 对每一层的输出blobs循环
            for (int top_id = 0; top_id < top_vecs_[layer_id].size(); ++top_id) {

                if (blob_loss_weights_.size() <= top_id_vecs_[layer_id][top_id]) {
                    blob_loss_weights_.resize(top_id_vecs_[layer_id][top_id] + 1, Dtype(0));
                }
                blob_loss_weights_[top_id_vecs_[layer_id][top_id]] = layer->loss(top_id);
                LOG_IF(INFO, Caffe::root_solver())
                << "Top shape: " << top_vecs_[layer_id][top_id]->shape_string();

                if (layer->loss(top_id)) {
                    LOG_IF(INFO, Caffe::root_solver())
                    << "    with loss weight " << layer->loss(top_id);
                }

                // 计算网络所使用的字节数
                memory_used_ += top_vecs_[layer_id][top_id]->count();
            }

            // 打印目前所需的存储
            LOG_IF(INFO, Caffe::root_solver())
            << "Memory required for data: " << memory_used_ * sizeof(Dtype);

            // param通常用来设置学习率之类的参数，每层的param有多少个则说明至少有这么多个
            // 可学习参数
            const int param_size = layer_param.param_size();

            //可学习参数个数
            const int num_param_blobs = layers_[layer_id]->blobs().size();

            CHECK_LE(param_size, num_param_blobs)
                << "Too many params specified for layer " << layer_param.name();

            ParamSpec default_param_spec;

            // 对每一个可学习的参数循环
            for (int param_id = 0; param_id < num_param_blobs; ++param_id) {

                // 如果prototxt文件没有设置param，则使用默认param
                const ParamSpec* param_spec = (param_id < param_size) ?
                                              &layer_param.param(param_id) : &default_param_spec;

                // 学习率不等于0，表示需要对这个可学习的参数反向求导
                const bool param_need_backward = param_spec->lr_mult() != 0;
                need_backward |= param_need_backward;

                layers_[layer_id]->set_param_propagate_down(param_id,
                                                            param_need_backward);
            }

            // 接下来的工作是将每层的parameter的指针塞进params_，尤其是learnable_params_。
            // 对每一层的每个可学习参数循环
            for (int param_id = 0; param_id < num_param_blobs; ++param_id) {
                // param：整个网络参数，layer_id:层数id，param_id:可学习参数id
                // 设置每一层权值的一些参数，学习率，正则率，参数id等
                AppendParam(param, layer_id, param_id);
            }

            // Finally, set the backward flag
            // 最后设置反向传播标志
            layer_need_backward_.push_back(need_backward);
            if (need_backward) {
                for (int top_id = 0; top_id < top_id_vecs_[layer_id].size(); ++top_id) {
                    blob_need_backward_[top_id_vecs_[layer_id][top_id]] = true;
                }
            }
        }
// 每一层的循环在这里结束



        // Go through the net backwards to determine which blobs contribute to the
        // loss.  We can skip backward computation for blobs that don't contribute
        // to the loss.
        // 寻找反向传播过程中哪些blobs对最终的loss有影响，如果某个blob对最终的loss没有贡献，
        // 则不需要对这个blob求梯度
        // Also checks if all bottom blobs don't need backward computation (possible
        // because the skip_propagate_down param) and so we can skip bacward
        // computation for the entire layer
        // 还要检查是否所有的bottom blobs都不需要求梯度

        set<string> blobs_under_loss;
        set<string> blobs_skip_backp;

        // 对每一层从后向前循环
        for (int layer_id = layers_.size() - 1; layer_id >= 0; --layer_id) {

            bool layer_contributes_loss = false;
            bool layer_skip_propagate_down = true;

            // 对每一层的每个top blob循环
            for (int top_id = 0; top_id < top_vecs_[layer_id].size(); ++top_id) {
                const string& blob_name = blob_names_[top_id_vecs_[layer_id][top_id]];

                if (layers_[layer_id]->loss(top_id) ||
                    (blobs_under_loss.find(blob_name) != blobs_under_loss.end())) {
                    layer_contributes_loss = true;
                }

                if (blobs_skip_backp.find(blob_name) == blobs_skip_backp.end()) {
                    layer_skip_propagate_down = false;
                }

                // 只要这一层有一个blob对loss有贡献，就说明这层对loss有贡献
                if (layer_contributes_loss && !layer_skip_propagate_down)
                    break;
            }

            // If this layer can skip backward computation, also all his bottom blobs
            // don't need backpropagation
            // 如果这一层跳过梯度计算，那么这一层所有的输入blobs都不需要计算梯度
            if (layer_need_backward_[layer_id] && layer_skip_propagate_down) {
                layer_need_backward_[layer_id] = false;
                for (int bottom_id = 0; bottom_id < bottom_vecs_[layer_id].size();
                     ++bottom_id) {
                    bottom_need_backward_[layer_id][bottom_id] = false;
                }
            }

            if (!layer_contributes_loss) { layer_need_backward_[layer_id] = false; }

            if (Caffe::root_solver()) {
                if (layer_need_backward_[layer_id]) {
                    LOG(INFO) << layer_names_[layer_id] << " needs backward computation.";
                }
                else {
                    LOG(INFO) << layer_names_[layer_id]
                              << " does not need backward computation.";
                }
            }

            for (int bottom_id = 0; bottom_id < bottom_vecs_[layer_id].size();
                 ++bottom_id) {
                if (layer_contributes_loss) {
                    const string& blob_name =
                            blob_names_[bottom_id_vecs_[layer_id][bottom_id]];
                    blobs_under_loss.insert(blob_name);
                }
                else {
                    bottom_need_backward_[layer_id][bottom_id] = false;
                }
                if (!bottom_need_backward_[layer_id][bottom_id]) {
                    const string& blob_name =
                            blob_names_[bottom_id_vecs_[layer_id][bottom_id]];
                    blobs_skip_backp.insert(blob_name);
                }
            }
        }
        // 从后向前循环结束

        // Handle force_backward if needed.
        // 如果设置强制计算梯度
        if (param.force_backward()) {
            for (int layer_id = 0; layer_id < layers_.size(); ++layer_id) {
                layer_need_backward_[layer_id] = true;
                for (int bottom_id = 0;
                     bottom_id < bottom_need_backward_[layer_id].size(); ++bottom_id) {
                    bottom_need_backward_[layer_id][bottom_id] =
                            bottom_need_backward_[layer_id][bottom_id] ||
                            layers_[layer_id]->AllowForceBackward(bottom_id);
                    blob_need_backward_[bottom_id_vecs_[layer_id][bottom_id]] =
                            blob_need_backward_[bottom_id_vecs_[layer_id][bottom_id]] ||
                            bottom_need_backward_[layer_id][bottom_id];
                }
                for (int param_id = 0; param_id < layers_[layer_id]->blobs().size();
                     ++param_id) {
                    layers_[layer_id]->set_param_propagate_down(param_id, true);
                }
            }
        }


        // 最后，输入输出blob中除了输入blob剩下的都作为网络的输出，比如loss blob
        for (set<string>::iterator it = available_blobs.begin();
             it != available_blobs.end(); ++it) {
            LOG_IF(INFO, Caffe::root_solver())
            << "This network produces output " << *it;
            net_output_blobs_.push_back(blobs_[blob_name_to_idx[*it]].get());
            net_output_blob_indices_.push_back(blob_name_to_idx[*it]);
        }

        for (size_t blob_id = 0; blob_id < blob_names_.size(); ++blob_id) {
            blob_names_index_[blob_names_[blob_id]] = blob_id;
        }

        for (size_t layer_id = 0; layer_id < layer_names_.size(); ++layer_id) {
            layer_names_index_[layer_names_[layer_id]] = layer_id;
        }

        ShareWeights();
        debug_info_ = param.debug_info();
        LOG_IF(INFO, Caffe::root_solver()) << "Network initialization done.";
    }

    template <typename Dtype>
    Dtype Net<Dtype>::ForwardFromTo(int start, int end) {
        CHECK_GE(start, 0);
        CHECK_LT(end, layers_.size());
        Dtype loss = 0;
        for (int i = start; i <= end; ++i) {
            // LOG(ERROR) << "Forwarding " << layer_names_[i];

            // 对每一层进行前向计算，返回每层的loss，其实只有最后一层loss不为0
            Dtype layer_loss = layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);
            loss += layer_loss;
            if (debug_info_) { ForwardDebugInfo(i); }
        }
        return loss;
    }

    template <typename Dtype>
    Dtype Net<Dtype>::ForwardFrom(int start) {
        return ForwardFromTo(start, layers_.size() - 1);
    }

    template <typename Dtype>
    Dtype Net<Dtype>::ForwardTo(int end) {
        return ForwardFromTo(0, end);
    }

    // 前向传播
    template <typename Dtype>
    const vector<Blob<Dtype>*>& Net<Dtype>::Forward(Dtype* loss) {

        // ？？应该是训练过程的前向传播
        if (loss != NULL) {
            *loss = ForwardFromTo(0, layers_.size() - 1);
        }

        else {
            ForwardFromTo(0, layers_.size() - 1);
        }
        return net_output_blobs_;
    }

    template <typename Dtype>
    const vector<Blob<Dtype>*>& Net<Dtype>::Forward(
            const vector<Blob<Dtype>*> & bottom, Dtype* loss) {
        LOG_EVERY_N(WARNING, 1000) << "DEPRECATED: Forward(bottom, loss) "
                                   << "will be removed in a future version. Use Forward(loss).";
        // Copy bottom to net bottoms
        for (int i = 0; i < bottom.size(); ++i) {
            net_input_blobs_[i]->CopyFrom(*bottom[i]);
        }
        return Forward(loss);
    }

    // 与前向传播一样，反向传播也有很多相关函数，但都是对BackwardFromTo(int start, int end)的封装
    template <typename Dtype>
    void Net<Dtype>::BackwardFromTo(int start, int end) {
        CHECK_GE(end, 0);
        CHECK_LT(start, layers_.size());
        for (int i = start; i >= end; --i) {
            if (layer_need_backward_[i]) {
                // 对每一层经行反向传播计算
                layers_[i]->Backward(
                        top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);
                if (debug_info_) { BackwardDebugInfo(i); }
            }
        }
    }

    template <typename Dtype>
    void Net<Dtype>::BackwardFrom(int start) {
        BackwardFromTo(start, 0);
    }

    template <typename Dtype>
    void Net<Dtype>::BackwardTo(int end) {
        BackwardFromTo(layers_.size() - 1, end);
    }

    template <typename Dtype>
    void Net<Dtype>::Backward() {
        BackwardFromTo(layers_.size() - 1, 0);
        if (debug_info_) {
            Dtype asum_data = 0, asum_diff = 0, sumsq_data = 0, sumsq_diff = 0;
            for (int i = 0; i < learnable_params_.size(); ++i) {
                asum_data += learnable_params_[i]->asum_data();
                asum_diff += learnable_params_[i]->asum_diff();
                sumsq_data += learnable_params_[i]->sumsq_data();
                sumsq_diff += learnable_params_[i]->sumsq_diff();
            }
            const Dtype l2norm_data = std::sqrt(sumsq_data);
            const Dtype l2norm_diff = std::sqrt(sumsq_diff);
            LOG(ERROR) << "    [Backward] All net params (data, diff): "
                       << "L1 norm = (" << asum_data << ", " << asum_diff << "); "
                       << "L2 norm = (" << l2norm_data << ", " << l2norm_diff << ")";
        }
    }

// 如果进行预测或这fine-tuning，就需要将载入预训练的权值，Net类提供的函数CopyTrainedLayersFrom(const string& trained_file)可以实现这个过程
    template <typename Dtype>
    void Net<Dtype>::CopyTrainedLayersFrom(const NetParameter& param) {
        int num_source_layers = param.layer_size();
        for (int i = 0; i < num_source_layers; ++i) {
            const LayerParameter& source_layer = param.layer(i);
            const string& source_layer_name = source_layer.name();
            int target_layer_id = 0;
            while (target_layer_id != layer_names_.size() &&
                   layer_names_[target_layer_id] != source_layer_name) {
                ++target_layer_id;
            }
            if (target_layer_id == layer_names_.size()) {
                LOG(INFO) << "Ignoring source layer " << source_layer_name;
                continue;
            }
            DLOG(INFO) << "Copying source layer " << source_layer_name;
            vector<shared_ptr<Blob<Dtype> > >& target_blobs =
                    layers_[target_layer_id]->blobs();
            CHECK_EQ(target_blobs.size(), source_layer.blobs_size())
                << "Incompatible number of blobs for layer " << source_layer_name;
            for (int j = 0; j < target_blobs.size(); ++j) {
                if (!target_blobs[j]->ShapeEquals(source_layer.blobs(j))) {
                    Blob<Dtype> source_blob;
                    const bool kReshape = true;
                    source_blob.FromProto(source_layer.blobs(j), kReshape);
                    LOG(FATAL) << "Cannot copy param " << j << " weights from layer '"
                               << source_layer_name << "'; shape mismatch.  Source param shape is "
                               << source_blob.shape_string() << "; target param shape is "
                               << target_blobs[j]->shape_string() << ". "
                               << "To learn this layer's parameters from scratch rather than "
                               << "copying from a saved net, rename the layer.";
                }
                const bool kReshape = false;
                target_blobs[j]->FromProto(source_layer.blobs(j), kReshape);
            }
        }
    }

    template <typename Dtype>
    void Net<Dtype>::CopyTrainedLayersFrom(const string trained_filename) {
        if (trained_filename.size() >= 3 &&
            trained_filename.compare(trained_filename.size() - 3, 3, ".h5") == 0) {
            CopyTrainedLayersFromHDF5(trained_filename);
        } else {
            CopyTrainedLayersFromBinaryProto(trained_filename);
        }
    }

    template <typename Dtype>
    void Net<Dtype>::CopyTrainedLayersFromBinaryProto(
            const string trained_filename) {
        NetParameter param;
        ReadProtoFromBinaryFile(trained_filename, &param);
        CopyTrainedLayersFrom(param);
    }

    template <typename Dtype>
    void Net<Dtype>::CopyTrainedLayersFromHDF5(const string trained_filename) {
//        hid_t file_hid = H5Fopen(trained_filename.c_str(), H5F_ACC_RDONLY,
//                                 H5P_DEFAULT);
//        CHECK_GE(file_hid, 0) << "Couldn't open " << trained_filename;
//        hid_t data_hid = H5Gopen2(file_hid, "data", H5P_DEFAULT);
//        CHECK_GE(data_hid, 0) << "Error reading weights from " << trained_filename;
//        int num_layers = hdf5_get_num_links(data_hid);
//        for (int i = 0; i < num_layers; ++i) {
//            string source_layer_name = hdf5_get_name_by_idx(data_hid, i);
//            if (!layer_names_index_.count(source_layer_name)) {
//                LOG(INFO) << "Ignoring source layer " << source_layer_name;
//                continue;
//            }
//            int target_layer_id = layer_names_index_[source_layer_name];
//            DLOG(INFO) << "Copying source layer " << source_layer_name;
//            vector<shared_ptr<Blob<Dtype> > >& target_blobs =
//                    layers_[target_layer_id]->blobs();
//            hid_t layer_hid = H5Gopen2(data_hid, source_layer_name.c_str(),
//                                       H5P_DEFAULT);
//            CHECK_GE(layer_hid, 0)
//                << "Error reading weights from " << trained_filename;
//            // Check that source layer doesn't have more params than target layer
//            int num_source_params = hdf5_get_num_links(layer_hid);
//            CHECK_LE(num_source_params, target_blobs.size())
//                << "Incompatible number of blobs for layer " << source_layer_name;
//            for (int j = 0; j < target_blobs.size(); ++j) {
//                ostringstream oss;
//                oss << j;
//                string dataset_name = oss.str();
//                int target_net_param_id = param_id_vecs_[target_layer_id][j];
//                if (!H5Lexists(layer_hid, dataset_name.c_str(), H5P_DEFAULT)) {
//                    // Target param doesn't exist in source weights...
//                    if (param_owners_[target_net_param_id] != -1) {
//                        // ...but it's weight-shared in target, so that's fine.
//                        continue;
//                    } else {
//                        LOG(FATAL) << "Incompatible number of blobs for layer "
//                                   << source_layer_name;
//                    }
//                }
//                hdf5_load_nd_dataset(layer_hid, dataset_name.c_str(), 0, kMaxBlobAxes,
//                                     target_blobs[j].get());
//            }
//            H5Gclose(layer_hid);
//        }
//        H5Gclose(data_hid);
//        H5Fclose(file_hid);
    }

    template <typename Dtype>
    void Net<Dtype>::ToProto(NetParameter* param, bool write_diff) const {
        param->Clear();
        param->set_name(name_);
        // Add bottom and top
        DLOG(INFO) << "Serializing " << layers_.size() << " layers";
        for (int i = 0; i < layers_.size(); ++i) {
            LayerParameter* layer_param = param->add_layer();
            layers_[i]->ToProto(layer_param, write_diff);
        }
    }

    template <typename Dtype>
    void Net<Dtype>::ToHDF5(const string& filename, bool write_diff) const {
//        hid_t file_hid = H5Fcreate(filename.c_str(), H5F_ACC_TRUNC, H5P_DEFAULT,
//                                   H5P_DEFAULT);
//        CHECK_GE(file_hid, 0)
//            << "Couldn't open " << filename << " to save weights.";
//        hid_t data_hid = H5Gcreate2(file_hid, "data", H5P_DEFAULT, H5P_DEFAULT,
//                                    H5P_DEFAULT);
//        CHECK_GE(data_hid, 0) << "Error saving weights to " << filename << ".";
//        hid_t diff_hid = -1;
//        if (write_diff) {
//            diff_hid = H5Gcreate2(file_hid, "diff", H5P_DEFAULT, H5P_DEFAULT,
//                                  H5P_DEFAULT);
//            CHECK_GE(diff_hid, 0) << "Error saving weights to " << filename << ".";
//        }
//        for (int layer_id = 0; layer_id < layers_.size(); ++layer_id) {
//            const LayerParameter& layer_param = layers_[layer_id]->layer_param();
//            string layer_name = layer_param.name();
//            hid_t layer_data_hid = H5Gcreate2(data_hid, layer_name.c_str(),
//                                              H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
//            CHECK_GE(layer_data_hid, 0)
//                << "Error saving weights to " << filename << ".";
//            hid_t layer_diff_hid = -1;
//            if (write_diff) {
//                layer_diff_hid = H5Gcreate2(diff_hid, layer_name.c_str(),
//                                            H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
//                CHECK_GE(layer_diff_hid, 0)
//                    << "Error saving weights to " << filename << ".";
//            }
//            int num_params = layers_[layer_id]->blobs().size();
//            for (int param_id = 0; param_id < num_params; ++param_id) {
//                ostringstream dataset_name;
//                dataset_name << param_id;
//                const int net_param_id = param_id_vecs_[layer_id][param_id];
//                if (param_owners_[net_param_id] == -1) {
//                    // Only save params that own themselves
//                    hdf5_save_nd_dataset<Dtype>(layer_data_hid, dataset_name.str(),
//                                                *params_[net_param_id]);
//                }
//                if (write_diff) {
//                    // Write diffs regardless of weight-sharing
//                    hdf5_save_nd_dataset<Dtype>(layer_diff_hid, dataset_name.str(),
//                                                *params_[net_param_id], true);
//                }
//            }
//            H5Gclose(layer_data_hid);
//            if (write_diff) {
//                H5Gclose(layer_diff_hid);
//            }
//        }
//        H5Gclose(data_hid);
//        if (write_diff) {
//            H5Gclose(diff_hid);
//        }
//        H5Fclose(file_hid);
    }


    template <typename Dtype>
    void Net<Dtype>::ClearParamDiffs() {
        for (int i = 0; i < learnable_params_.size(); ++i) {
            Blob<Dtype>* blob = learnable_params_[i];
            switch (Caffe::mode()) {
                case Caffe::CPU:
                    caffe_set(blob->count(), static_cast<Dtype>(0),
                              blob->mutable_cpu_diff());
                    break;
                case Caffe::GPU:
#ifndef CPU_ONLY
                    //TODO NO implement
//                    caffe_gpu_set(blob->count(), static_cast<Dtype>(0),
//                                  blob->mutable_gpu_diff());
#else
                    NO_GPU;
#endif
                    break;
            }
        }
    }

    template <typename Dtype>
    void Net<Dtype>::Reshape() {
        for (int i = 0; i < layers_.size(); ++i) {
            layers_[i]->Reshape(bottom_vecs_[i], top_vecs_[i]);
        }
    }

    // 在训练的过程中layer的权值要根据反向传播并累积的梯度进行更新，更新的过程由Update()完成。
    // 这个函数的功能十分明确，对每个存储learnable_parms的blob调用blob的Update()函数，来更新权值。
    template <typename Dtype>
    void Net<Dtype>::Update() {
        // 对每一个可学习参数更新权值
        for (int i = 0; i < learnable_params_.size(); ++i) {
            learnable_params_[i]->Update();
        }
    }

    template <typename Dtype>
    void Net<Dtype>::ShareWeights() {
        for (int i = 0; i < params_.size(); ++i) {
            if (param_owners_[i] < 0) { continue; }
            params_[i]->ShareData(*params_[param_owners_[i]]);
            params_[i]->ShareDiff(*params_[param_owners_[i]]);
        }
    }

    template <typename Dtype>
    void Net<Dtype>::ShareTrainedLayersWith(const Net* other) {
        int num_source_layers = other->layers().size();
        for (int i = 0; i < num_source_layers; ++i) {
            Layer<Dtype>* source_layer = other->layers()[i].get();
            const string& source_layer_name = other->layer_names()[i];
            int target_layer_id = 0;
            while (target_layer_id != layer_names_.size() &&
                   layer_names_[target_layer_id] != source_layer_name) {
                ++target_layer_id;
            }
            if (target_layer_id == layer_names_.size()) {
                LOG(INFO) << "Ignoring source layer " << source_layer_name;
                continue;
            }
            DLOG(INFO) << "Copying source layer " << source_layer_name;
            vector<shared_ptr<Blob<Dtype> > >& target_blobs =
                    layers_[target_layer_id]->blobs();
            CHECK_EQ(target_blobs.size(), source_layer->blobs().size())
                << "Incompatible number of blobs for layer " << source_layer_name;
            for (int j = 0; j < target_blobs.size(); ++j) {
                Blob<Dtype>* source_blob = source_layer->blobs()[j].get();
                CHECK(target_blobs[j]->shape() == source_blob->shape())
                << "Cannot share param " << j << " weights from layer '"
                << source_layer_name << "'; shape mismatch.  Source param shape is "
                << source_blob->shape_string() << "; target param shape is "
                << target_blobs[j]->shape_string();
                target_blobs[j]->ShareData(*source_blob);
            }
        }
    }

    // Helper for Net::Init: add a new top blob to the net.
    template <typename Dtype>
    void Net<Dtype>::AppendTop(const NetParameter& param, const int layer_id,
                               const int top_id, set<string>* available_blobs,
                               map<string, int>* blob_name_to_idx) {
        // 每层参数
        shared_ptr<LayerParameter> layer_param(
                new LayerParameter(param.layer(layer_id)));

        // 每个输出blob的名称
        const string& blob_name = (layer_param->top_size() > top_id) ?
                                  layer_param->top(top_id) : "(automatic)";

        // Check if we are doing in-place computation
        // 检查是否为同址计算（in-place computation，返回值覆盖原值而不占用新的内存）。
        // （比如Dropout运算，激活函数ReLu，Sigmoid等），其中输入bolb的名称和输出相同
        if (blob_name_to_idx && layer_param->bottom_size() > top_id &&
            blob_name == layer_param->bottom(top_id)) {

            // In-place computation
            LOG_IF(INFO, Caffe::root_solver())
            << layer_param->name() << " -> " << blob_name << " (in-place)";

            // get获取拥有的资源的地址。
            top_vecs_[layer_id].push_back(blobs_[(*blob_name_to_idx)[blob_name]].get());
            top_id_vecs_[layer_id].push_back((*blob_name_to_idx)[blob_name]);

        }
        else if (blob_name_to_idx &&
                 blob_name_to_idx->find(blob_name) != blob_name_to_idx->end()) {
            // If we are not doing in-place computation but have duplicated blobs,
            // raise an error.
            LOG(FATAL) << "Top blob '" << blob_name
                       << "' produced by multiple sources.";
        }
        else {
            // Normal output.
            if (Caffe::root_solver()) {
                LOG(INFO) << layer_param->name() << " -> " << blob_name;
            }

            // 数据指针
            shared_ptr<Blob<Dtype> > blob_pointer(new Blob<Dtype>());

            // blobs只是存储中间结果；每次遍历到一个top blob都会更新blob_id
            const int blob_id = blobs_.size();
            blobs_.push_back(blob_pointer);
            blob_names_.push_back(blob_name);
            blob_need_backward_.push_back(false);
            // blob_name_to_idx是一个局部变量，其实它是在当前layer的top blob 和下一层的bottom blob间起着一个桥梁作用。
            // blob_name_to_idx中元素的pair是从网络最开始一层一层搭建的过程中压入map的，其中的name和id都是不重复的。name是关键字——不重复是map数据结构的必然要求，id也是不重复的——0,1,2...
            // blob_name_to_idx和blobs_一样，在"Normal output"的情形下，每次遍历到一个top blob的时候都会更新


            // 添加新元素-->map可以通过下标访问符为（关联）容器添加新元素
            if (blob_name_to_idx) {
                (*blob_name_to_idx)[blob_name] = blob_id; }
            top_id_vecs_[layer_id].push_back(blob_id);
            top_vecs_[layer_id].push_back(blob_pointer.get());
        }

        if (available_blobs) { available_blobs->insert(blob_name); }
    }

    template <typename Dtype>
    int Net<Dtype>::AppendBottom(const NetParameter& param, const int layer_id,
                                 const int bottom_id, set<string>* available_blobs,
                                 map<string, int>* blob_name_to_idx) {

        //得到这一层的参数
        const LayerParameter& layer_param = param.layer(layer_id);

        //得到输入bottom的名称
        const string& blob_name = layer_param.bottom(bottom_id);


        if (available_blobs->find(blob_name) == available_blobs->end()) {
            LOG(FATAL) << "Unknown bottom blob '" << blob_name << "' (layer '"
                       << layer_param.name() << "', bottom index " << bottom_id << ")";
        }

        // blob_name_to_idx是一个map,其关键字是不重复的。blob_name_to_idx
        LOG(INFO) <<  " -> " << blob_name<<" "<<(*blob_name_to_idx).size()<<"heheda";
        const int blob_id = (*blob_name_to_idx)[blob_name];
        LOG(INFO) <<  " -> " << blob_name<<" "<<blob_id<<(*blob_name_to_idx).size()<<"heheda";
        //
        LOG_IF(INFO, Caffe::root_solver())
        << layer_names_[layer_id] << " <- " << blob_name;

        bottom_vecs_[layer_id].push_back(blobs_[blob_id].get());
        bottom_id_vecs_[layer_id].push_back(blob_id);
        available_blobs->erase(blob_name);

        bool need_backward = blob_need_backward_[blob_id];
        // Check if the backpropagation on bottom_id should be skipped
        if (layer_param.propagate_down_size() > 0) {
            need_backward = layer_param.propagate_down(bottom_id);
        }
        bottom_need_backward_[layer_id].push_back(need_backward);
        return blob_id;
    }

    template <typename Dtype>
    void Net<Dtype>::AppendParam(const NetParameter& param, const int layer_id,
                                 const int param_id) {
        const LayerParameter& layer_param = layers_[layer_id]->layer_param();
        const int param_size = layer_param.param_size();
        string param_name =
                (param_size > param_id) ? layer_param.param(param_id).name() : "";
        if (param_name.size()) {
            param_display_names_.push_back(param_name);
        } else {
            ostringstream param_display_name;
            param_display_name << param_id;
            param_display_names_.push_back(param_display_name.str());
        }
        const int net_param_id = params_.size();

        // 存放每个可学习参数
        params_.push_back(layers_[layer_id]->blobs()[param_id]);
        param_id_vecs_[layer_id].push_back(net_param_id);

        // pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。
        // 初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，
        param_layer_indices_.push_back(make_pair(layer_id, param_id));
        ParamSpec default_param_spec;
        const ParamSpec* param_spec = (layer_param.param_size() > param_id) ?
                                      &layer_param.param(param_id) : &default_param_spec;

        if (!param_size || !param_name.size() || (param_name.size() &&
                                                  param_names_index_.find(param_name) == param_names_index_.end())) {
            // This layer "owns" this parameter blob -- it is either anonymous
            // (i.e., not given a param_name) or explicitly given a name that we
            // haven't already seen.
            //
            param_owners_.push_back(-1);
            if (param_name.size()) {
                param_names_index_[param_name] = net_param_id;
            }

            const int learnable_param_id = learnable_params_.size();

            // 智能指针转换为普通指针，Why？
            learnable_params_.push_back(params_[net_param_id].get());
            learnable_param_ids_.push_back(learnable_param_id);
            has_params_lr_.push_back(param_spec->has_lr_mult());
            has_params_decay_.push_back(param_spec->has_decay_mult());
            params_lr_.push_back(param_spec->lr_mult());
            params_weight_decay_.push_back(param_spec->decay_mult());
        }
            // 真个else直到结束，一般不会执行这一部分，共享网络如siamese model会执行
        else
        {
            // Named param blob with name we've seen before: share params
            const int owner_net_param_id = param_names_index_[param_name];
            param_owners_.push_back(owner_net_param_id);
            const pair<int, int>& owner_index =
                    param_layer_indices_[owner_net_param_id];
            const int owner_layer_id = owner_index.first;
            const int owner_param_id = owner_index.second;
            LOG_IF(INFO, Caffe::root_solver()) << "Sharing parameters '" << param_name
                                               << "' owned by "
                                               << "layer '" << layer_names_[owner_layer_id] << "', param "
                                               << "index " << owner_param_id;
            Blob<Dtype>* this_blob = layers_[layer_id]->blobs()[param_id].get();
            Blob<Dtype>* owner_blob =
                    layers_[owner_layer_id]->blobs()[owner_param_id].get();
            const int param_size = layer_param.param_size();
            if (param_size > param_id && (layer_param.param(param_id).share_mode() ==
                                          ParamSpec_DimCheckMode_PERMISSIVE)) {
                // Permissive dimension checking -- only check counts are the same.
                CHECK_EQ(this_blob->count(), owner_blob->count())
                    << "Cannot share param '" << param_name << "' owned by layer '"
                    << layer_names_[owner_layer_id] << "' with layer '"
                    << layer_names_[layer_id] << "'; count mismatch.  Owner layer param "
                    << "shape is " << owner_blob->shape_string() << "; sharing layer "
                    << "shape is " << this_blob->shape_string();
            } else {
                // Strict dimension checking -- all dims must be the same.
                CHECK(this_blob->shape() == owner_blob->shape())
                << "Cannot share param '" << param_name << "' owned by layer '"
                << layer_names_[owner_layer_id] << "' with layer '"
                << layer_names_[layer_id] << "'; shape mismatch.  Owner layer param "
                << "shape is " << owner_blob->shape_string() << "; sharing layer "
                << "expects shape " << this_blob->shape_string();
            }
            const int learnable_param_id = learnable_param_ids_[owner_net_param_id];
            learnable_param_ids_.push_back(learnable_param_id);
            if (param_spec->has_lr_mult()) {
                if (has_params_lr_[learnable_param_id]) {
                    CHECK_EQ(param_spec->lr_mult(), params_lr_[learnable_param_id])
                        << "Shared param '" << param_name << "' has mismatched lr_mult.";
                } else {
                    has_params_lr_[learnable_param_id] = true;
                    params_lr_[learnable_param_id] = param_spec->lr_mult();
                }
            }
            if (param_spec->has_decay_mult()) {
                if (has_params_decay_[learnable_param_id]) {
                    CHECK_EQ(param_spec->decay_mult(),
                             params_weight_decay_[learnable_param_id])
                        << "Shared param '" << param_name << "' has mismatched decay_mult.";
                } else {
                    has_params_decay_[learnable_param_id] = true;
                    params_weight_decay_[learnable_param_id] = param_spec->decay_mult();
                }
            }
        }
    }

    template <typename Dtype>
    void Net<Dtype>::ForwardDebugInfo(const int layer_id) {
        for (int top_id = 0; top_id < top_vecs_[layer_id].size(); ++top_id) {
            const Blob<Dtype>& blob = *top_vecs_[layer_id][top_id];
            const string& blob_name = blob_names_[top_id_vecs_[layer_id][top_id]];
            const Dtype data_abs_val_mean = blob.asum_data() / blob.count();
            LOG_IF(INFO, Caffe::root_solver())
            << "    [Forward] "
            << "Layer " << layer_names_[layer_id]
            << ", top blob " << blob_name
            << " data: " << data_abs_val_mean;
        }
        for (int param_id = 0; param_id < layers_[layer_id]->blobs().size();
             ++param_id) {
            const Blob<Dtype>& blob = *layers_[layer_id]->blobs()[param_id];
            const int net_param_id = param_id_vecs_[layer_id][param_id];
            const string& blob_name = param_display_names_[net_param_id];
            const Dtype data_abs_val_mean = blob.asum_data() / blob.count();
            LOG_IF(INFO, Caffe::root_solver())
            << "    [Forward] "
            << "Layer " << layer_names_[layer_id]
            << ", param blob " << blob_name
            << " data: " << data_abs_val_mean;
        }
    }

    template <typename Dtype>
    void Net<Dtype>::BackwardDebugInfo(const int layer_id) {
        const vector<Blob<Dtype>*>& bottom_vec = bottom_vecs_[layer_id];
        for (int bottom_id = 0; bottom_id < bottom_vec.size(); ++bottom_id) {
            if (!bottom_need_backward_[layer_id][bottom_id]) { continue; }
            const Blob<Dtype>& blob = *bottom_vec[bottom_id];
            const string& blob_name = blob_names_[bottom_id_vecs_[layer_id][bottom_id]];
            const Dtype diff_abs_val_mean = blob.asum_diff() / blob.count();
            LOG_IF(INFO, Caffe::root_solver())
            << "    [Backward] "
            << "Layer " << layer_names_[layer_id]
            << ", bottom blob " << blob_name
            << " diff: " << diff_abs_val_mean;
        }
        for (int param_id = 0; param_id < layers_[layer_id]->blobs().size();
             ++param_id) {
            if (!layers_[layer_id]->param_propagate_down(param_id)) { continue; }
            const Blob<Dtype>& blob = *layers_[layer_id]->blobs()[param_id];
            const Dtype diff_abs_val_mean = blob.asum_diff() / blob.count();
            LOG_IF(INFO, Caffe::root_solver())
            << "    [Backward] "
            << "Layer " << layer_names_[layer_id]
            << ", param blob " << param_id
            << " diff: " << diff_abs_val_mean;
        }
    }



    template <typename Dtype>
    void Net<Dtype>::FilterNet(const NetParameter& param,
                               NetParameter* param_filtered) {

        NetState net_state(param.state());
        param_filtered->CopyFrom(param);
        param_filtered->clear_layer();

        for (int i = 0; i < param.layer_size(); ++i) {
            const LayerParameter& layer_param = param.layer(i);
            const string& layer_name = layer_param.name();

            CHECK(layer_param.include_size() == 0 || layer_param.exclude_size() == 0)
            << "Specify either include rules or exclude rules; not both.";

            bool layer_included = (layer_param.include_size() == 0);
            for (int j = 0; layer_included && j < layer_param.exclude_size(); ++j) {
                if (StateMeetsRule(net_state, layer_param.exclude(j), layer_name)) {
                    layer_included = false;
                }
            }
            for (int j = 0; !layer_included && j < layer_param.include_size(); ++j) {
                if (StateMeetsRule(net_state, layer_param.include(j), layer_name)) {
                    layer_included = true;
                }
            }
            if (layer_included) {
                param_filtered->add_layer()->CopyFrom(layer_param);
            }

        }

    }

    // 判断每层是属于什么网络的，include or exclude
    template <typename Dtype>
    bool Net<Dtype>::StateMeetsRule(const NetState& state,
                                    const NetStateRule& rule, const string& layer_name) {
        // Check whether the rule is broken due to phase.
        if (rule.has_phase()) {
            if (rule.phase() != state.phase()) {
                LOG_IF(INFO, Caffe::root_solver())
                << "The NetState phase (" << state.phase()
                << ") differed from the phase (" << rule.phase()
                << ") specified by a rule in layer " << layer_name;
                return false;
            }
        }
        // Check whether the rule is broken due to min level.
        if (rule.has_min_level()) {
            if (state.level() < rule.min_level()) {
                LOG_IF(INFO, Caffe::root_solver())
                << "The NetState level (" << state.level()
                << ") is above the min_level (" << rule.min_level()
                << ") specified by a rule in layer " << layer_name;
                return false;
            }
        }
        // Check whether the rule is broken due to max level.
        if (rule.has_max_level()) {
            if (state.level() > rule.max_level()) {
                LOG_IF(INFO, Caffe::root_solver())
                << "The NetState level (" << state.level()
                << ") is above the max_level (" << rule.max_level()
                << ") specified by a rule in layer " << layer_name;
                return false;
            }
        }
        // Check whether the rule is broken due to stage. The NetState must
        // contain ALL of the rule's stages to meet it.
        for (int i = 0; i < rule.stage_size(); ++i) {
            // Check that the NetState contains the rule's ith stage.
            bool has_stage = false;
            for (int j = 0; !has_stage && j < state.stage_size(); ++j) {
                if (rule.stage(i) == state.stage(j)) { has_stage = true; }
            }
            if (!has_stage) {
                LOG_IF(INFO, Caffe::root_solver())
                << "The NetState did not contain stage '" << rule.stage(i)
                << "' specified by a rule in layer " << layer_name;
                return false;
            }
        }
        // Check whether the rule is broken due to not_stage. The NetState must
        // contain NONE of the rule's not_stages to meet it.
        for (int i = 0; i < rule.not_stage_size(); ++i) {
            // Check that the NetState contains the rule's ith not_stage.
            bool has_stage = false;
            for (int j = 0; !has_stage && j < state.stage_size(); ++j) {
                if (rule.not_stage(i) == state.stage(j)) { has_stage = true; }
            }
            if (has_stage) {
                LOG_IF(INFO, Caffe::root_solver())
                << "The NetState contained a not_stage '" << rule.not_stage(i)
                << "' specified by a rule in layer " << layer_name;
                return false;
            }
        }
        return true;
    }

    template <typename Dtype>
    bool Net<Dtype>::has_blob(const string& blob_name) const {
        return blob_names_index_.find(blob_name) != blob_names_index_.end();
    }

    template <typename Dtype>
    const shared_ptr<Blob<Dtype> > Net<Dtype>::blob_by_name(
            const string& blob_name) const {
        shared_ptr<Blob<Dtype> > blob_ptr;
        if (has_blob(blob_name)) {
            blob_ptr = blobs_[blob_names_index_.find(blob_name)->second];
        } else {
            blob_ptr.reset((Blob<Dtype>*)(NULL));
            LOG(WARNING) << "Unknown blob name " << blob_name;
        }
        return blob_ptr;
    }

    template <typename Dtype>
    bool Net<Dtype>::has_layer(const string& layer_name) const {
        return layer_names_index_.find(layer_name) != layer_names_index_.end();
    }

    template <typename Dtype>
    const shared_ptr<Layer<Dtype> > Net<Dtype>::layer_by_name(
            const string& layer_name) const {
        shared_ptr<Layer<Dtype> > layer_ptr;
        if (has_layer(layer_name)) {
            layer_ptr = layers_[layer_names_index_.find(layer_name)->second];
        } else {
            layer_ptr.reset((Layer<Dtype>*)(NULL));
            LOG(WARNING) << "Unknown layer name " << layer_name;
        }
        return layer_ptr;
    }

//模板显示实例化
INSTANTIATE_CLASS(Net);
    
}